"""
Standalone AI Chat Desktop Application
Install requirements: pip install PyQt6 requests
Run: python desktop_chat_app.py
"""

import sys
import json
import requests
import sqlite3
from datetime import datetime
from pathlib import Path
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                             QHBoxLayout, QTextEdit, QPushButton, QLabel, 
                             QComboBox, QLineEdit, QListWidget, QSplitter,
                             QTabWidget, QSlider, QFileDialog, QMessageBox,
                             QScrollArea, QFrame)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QFont, QTextCursor, QPalette, QColor

# Database setup
DB_PATH = "chat_history.db"

def init_database():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute('''CREATE TABLE IF NOT EXISTS conversations
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  title TEXT,
                  provider TEXT,
                  model TEXT,
                  created_at TIMESTAMP,
                  updated_at TIMESTAMP)''')
    
    c.execute('''CREATE TABLE IF NOT EXISTS messages
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  conversation_id INTEGER,
                  role TEXT,
                  content TEXT,
                  timestamp TIMESTAMP,
                  FOREIGN KEY (conversation_id) REFERENCES conversations(id))''')
    
    c.execute('''CREATE TABLE IF NOT EXISTS usage_stats
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  conversation_id INTEGER,
                  provider TEXT,
                  model TEXT,
                  input_tokens INTEGER,
                  output_tokens INTEGER,
                  estimated_cost REAL,
                  timestamp TIMESTAMP,
                  FOREIGN KEY (conversation_id) REFERENCES conversations(id))''')
    
    conn.commit()
    conn.close()

# Provider configurations
PROVIDERS = {
    "ollama": {
        "name": "Ollama (Local)",
        "requires_api_key": False,
        "default_host": "http://localhost:11434"
    },
    "lmstudio": {
        "name": "LM Studio (Local)",
        "requires_api_key": False,
        "default_host": "http://localhost:1234"
    },
    "groq": {
        "name": "Groq",
        "requires_api_key": True
    },
    "openai": {
        "name": "OpenAI",
        "requires_api_key": True
    },
    "anthropic": {
        "name": "Anthropic",
        "requires_api_key": True
    }
}

# API worker thread
class APIWorker(QThread):
    finished = pyqtSignal(str, int, int)
    error = pyqtSignal(str)
    
    def __init__(self, provider, model, messages, settings):
        super().__init__()
        self.provider = provider
        self.model = model
        self.messages = messages
        self.settings = settings
    
    def run(self):
        try:
            if self.provider == "ollama":
                response, inp, out = self.call_ollama()
            elif self.provider == "lmstudio":
                response, inp, out = self.call_lmstudio()
            elif self.provider == "groq":
                response, inp, out = self.call_groq()
            elif self.provider == "openai":
                response, inp, out = self.call_openai()
            elif self.provider == "anthropic":
                response, inp, out = self.call_anthropic()
            else:
                raise Exception("Unknown provider")
            
            self.finished.emit(response, inp, out)
        except Exception as e:
            self.error.emit(str(e))
    
    def call_ollama(self):
        prompt = "\n".join([f"{m['role']}: {m['content']}" for m in self.messages])
        response = requests.post(
            f"{self.settings['ollama_host']}/api/generate",
            json={
                "model": self.model,
                "prompt": prompt,
                "stream": False,
                "options": {
                    "temperature": self.settings['temperature'],
                    "num_predict": self.settings['max_tokens']
                }
            },
            timeout=120
        )
        if response.status_code == 200:
            return response.json().get('response', ''), 0, 0
        raise Exception(f"Ollama error: {response.status_code}")
    
    def call_lmstudio(self):
        response = requests.post(
            f"{self.settings['lmstudio_host']}/v1/chat/completions",
            json={
                "model": self.model,
                "messages": self.messages,
                "temperature": self.settings['temperature'],
                "max_tokens": self.settings['max_tokens']
            },
            timeout=120
        )
        if response.status_code == 200:
            data = response.json()
            usage = data.get('usage', {})
            return (data['choices'][0]['message']['content'],
                   usage.get('prompt_tokens', 0),
                   usage.get('completion_tokens', 0))
        raise Exception(f"LM Studio error: {response.status_code}")
    
    def call_groq(self):
        response = requests.post(
            "https://api.groq.com/openai/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {self.settings['groq_api_key']}",
                "Content-Type": "application/json"
            },
            json={
                "model": self.model,
                "messages": self.messages,
                "temperature": self.settings['temperature'],
                "max_tokens": self.settings['max_tokens']
            },
            timeout=60
        )
        if response.status_code == 200:
            data = response.json()
            usage = data.get('usage', {})
            return (data['choices'][0]['message']['content'],
                   usage.get('prompt_tokens', 0),
                   usage.get('completion_tokens', 0))
        raise Exception(f"Groq error: {response.status_code}")
    
    def call_openai(self):
        response = requests.post(
            "https://api.openai.com/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {self.settings['openai_api_key']}",
                "Content-Type": "application/json"
            },
            json={
                "model": self.model,
                "messages": self.messages,
                "temperature": self.settings['temperature'],
                "max_tokens": self.settings['max_tokens']
            },
            timeout=60
        )
        if response.status_code == 200:
            data = response.json()
            usage = data.get('usage', {})
            return (data['choices'][0]['message']['content'],
                   usage.get('prompt_tokens', 0),
                   usage.get('completion_tokens', 0))
        raise Exception(f"OpenAI error: {response.status_code}")
    
    def call_anthropic(self):
        response = requests.post(
            "https://api.anthropic.com/v1/messages",
            headers={
                "x-api-key": self.settings['anthropic_api_key'],
                "anthropic-version": "2023-06-01",
                "Content-Type": "application/json"
            },
            json={
                "model": self.model,
                "messages": self.messages,
                "max_tokens": self.settings['max_tokens'],
                "temperature": self.settings['temperature']
            },
            timeout=60
        )
        if response.status_code == 200:
            data = response.json()
            usage = data.get('usage', {})
            return (data['content'][0]['text'],
                   usage.get('input_tokens', 0),
                   usage.get('output_tokens', 0))
        raise Exception(f"Anthropic error: {response.status_code}")

# Main window
class ChatWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("AI Chat Assistant")
        self.setGeometry(100, 100, 1400, 900)
        
        # Initialize database
        init_database()
        
        # State
        self.messages = []
        self.current_conversation_id = None
        self.current_provider = "ollama"
        self.current_model = ""
        self.provider_models = {}
        self.uploaded_files = []
        
        # Settings
        self.settings = {
            "ollama_host": "http://localhost:11434",
            "lmstudio_host": "http://localhost:1234",
            "groq_api_key": "",
            "openai_api_key": "",
            "anthropic_api_key": "",
            "temperature": 0.7,
            "max_tokens": 2048
        }
        
        self.setup_ui()
        self.apply_dark_theme()
        
        # Load models for default provider
        self.fetch_models()
    
    def setup_ui(self):
        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Main layout
        main_layout = QHBoxLayout(central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # Splitter for sidebar and main content
        splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Sidebar
        sidebar = self.create_sidebar()
        splitter.addWidget(sidebar)
        
        # Main content area
        main_content = self.create_main_content()
        splitter.addWidget(main_content)
        
        # Set splitter sizes (sidebar 300px, rest for content)
        splitter.setSizes([300, 1100])
        splitter.setStretchFactor(1, 1)
        
        main_layout.addWidget(splitter)
    
    def create_sidebar(self):
        sidebar = QFrame()
        sidebar.setMinimumWidth(280)
        sidebar.setMaximumWidth(400)
        sidebar.setFrameShape(QFrame.Shape.StyledPanel)
        
        layout = QVBoxLayout(sidebar)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        
        # Title
        title = QLabel("AI Chat Assistant")
        title.setFont(QFont("Arial", 16, QFont.Weight.Bold))
        layout.addWidget(title)
        
        # New chat button
        self.new_chat_btn = QPushButton("üó®Ô∏è New Chat")
        self.new_chat_btn.clicked.connect(self.new_chat)
        layout.addWidget(self.new_chat_btn)
        
        layout.addSpacing(10)
        
        # Provider selection
        provider_label = QLabel("AI Provider")
        provider_label.setFont(QFont("Arial", 11, QFont.Weight.Bold))
        layout.addWidget(provider_label)
        
        self.provider_combo = QComboBox()
        for provider_id, info in PROVIDERS.items():
            self.provider_combo.addItem(info["name"], provider_id)
        self.provider_combo.currentIndexChanged.connect(self.on_provider_changed)
        layout.addWidget(self.provider_combo)
        
        # Model selection
        model_layout = QHBoxLayout()
        model_label = QLabel("Model")
        model_label.setFont(QFont("Arial", 11, QFont.Weight.Bold))
        model_layout.addWidget(model_label)
        model_layout.addStretch()
        
        self.refresh_btn = QPushButton("üîÑ")
        self.refresh_btn.setMaximumWidth(40)
        self.refresh_btn.clicked.connect(self.fetch_models)
        model_layout.addWidget(self.refresh_btn)
        
        layout.addLayout(model_layout)
        
        self.model_combo = QComboBox()
        layout.addWidget(self.model_combo)
        
        self.model_status = QLabel()
        layout.addWidget(self.model_status)
        
        layout.addSpacing(10)
        
        # Settings tab
        self.settings_tab = QTabWidget()
        
        # API Settings
        api_settings = QWidget()
        api_layout = QVBoxLayout(api_settings)
        api_layout.setContentsMargins(10, 10, 10, 10)
        
        self.host_input = QLineEdit()
        self.host_input.setPlaceholderText("Host URL")
        self.host_input.textChanged.connect(self.update_host)
        api_layout.addWidget(QLabel("Host:"))
        api_layout.addWidget(self.host_input)
        
        self.api_key_input = QLineEdit()
        self.api_key_input.setPlaceholderText("API Key")
        self.api_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.api_key_input.textChanged.connect(self.update_api_key)
        api_layout.addWidget(QLabel("API Key:"))
        api_layout.addWidget(self.api_key_input)
        
        api_layout.addStretch()
        
        # Model Settings
        model_settings = QWidget()
        model_layout = QVBoxLayout(model_settings)
        model_layout.setContentsMargins(10, 10, 10, 10)
        
        temp_label = QLabel(f"Temperature: {self.settings['temperature']}")
        self.temp_slider = QSlider(Qt.Orientation.Horizontal)
        self.temp_slider.setMinimum(0)
        self.temp_slider.setMaximum(200)
        self.temp_slider.setValue(int(self.settings['temperature'] * 100))
        self.temp_slider.valueChanged.connect(lambda v: self.update_slider(temp_label, v, "temperature"))
        model_layout.addWidget(temp_label)
        model_layout.addWidget(self.temp_slider)
        
        tokens_label = QLabel(f"Max Tokens: {self.settings['max_tokens']}")
        self.tokens_slider = QSlider(Qt.Orientation.Horizontal)
        self.tokens_slider.setMinimum(256)
        self.tokens_slider.setMaximum(4096)
        self.tokens_slider.setSingleStep(256)
        self.tokens_slider.setValue(self.settings['max_tokens'])
        self.tokens_slider.valueChanged.connect(lambda v: self.update_slider(tokens_label, v, "max_tokens"))
        model_layout.addWidget(tokens_label)
        model_layout.addWidget(self.tokens_slider)
        
        model_layout.addStretch()
        
        self.settings_tab.addTab(api_settings, "API")
        self.settings_tab.addTab(model_settings, "Model")
        
        layout.addWidget(self.settings_tab)
        
        layout.addSpacing(10)
        
        # File upload
        file_label = QLabel("Upload File")
        file_label.setFont(QFont("Arial", 11, QFont.Weight.Bold))
        layout.addWidget(file_label)
        
        self.upload_btn = QPushButton("üìÅ Choose File")
        self.upload_btn.clicked.connect(self.upload_file)
        layout.addWidget(self.upload_btn)
        
        self.file_status = QLabel()
        layout.addWidget(self.file_status)
        
        layout.addSpacing(10)
        
        # Chat history
        history_label = QLabel("Chat History")
        history_label.setFont(QFont("Arial", 11, QFont.Weight.Bold))
        layout.addWidget(history_label)
        
        self.history_list = QListWidget()
        self.history_list.itemClicked.connect(self.load_conversation)
        layout.addWidget(self.history_list)
        
        self.load_history()
        
        layout.addStretch()
        
        return sidebar
    
    def create_main_content(self):
        main_widget = QWidget()
        layout = QVBoxLayout(main_widget)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # Chat display
        self.chat_display = QTextEdit()
        self.chat_display.setReadOnly(True)
        self.chat_display.setFont(QFont("Arial", 10))
        layout.addWidget(self.chat_display)
        
        # Input area
        input_layout = QHBoxLayout()
        
        self.message_input = QTextEdit()
        self.message_input.setMaximumHeight(100)
        self.message_input.setPlaceholderText("Type your message...")
        self.message_input.setFont(QFont("Arial", 10))
        input_layout.addWidget(self.message_input)
        
        self.send_btn = QPushButton("Send")
        self.send_btn.setMinimumHeight(100)
        self.send_btn.setMinimumWidth(100)
        self.send_btn.clicked.connect(self.send_message)
        input_layout.addWidget(self.send_btn)
        
        layout.addLayout(input_layout)
        
        return main_widget
    
    def apply_dark_theme(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(26, 26, 46))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(229, 229, 231))
        palette.setColor(QPalette.ColorRole.Base, QColor(31, 41, 55))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(30, 41, 59))
        palette.setColor(QPalette.ColorRole.Text, QColor(243, 244, 246))
        palette.setColor(QPalette.ColorRole.Button, QColor(59, 130, 246))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(255, 255, 255))
        palette.setColor(QPalette.ColorRole.Link, QColor(96, 165, 250))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(37, 99, 235))
        palette.setColor(QPalette.ColorRole.HighlightedText, QColor(255, 255, 255))
        
        self.setPalette(palette)
        QApplication.instance().setPalette(palette)
        
        # Style sheet
        self.setStyleSheet("""
            QMainWindow {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                    stop:0 #0f0f1e, stop:1 #1a1a2e);
            }
            QFrame {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #16213e, stop:1 #0f3460);
                border-right: 1px solid #1e3a5f;
            }
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #3b82f6, stop:1 #2563eb);
                color: white;
                border: none;
                border-radius: 6px;
                padding: 8px 16px;
                font-weight: 500;
                font-size: 13px;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #2563eb, stop:1 #1d4ed8);
            }
            QPushButton:pressed {
                background: #1e40af;
            }
            QLineEdit, QTextEdit, QComboBox {
                background-color: #1e293b;
                color: #f3f4f6;
                border: 1px solid #475569;
                border-radius: 6px;
                padding: 8px;
                font-size: 13px;
            }
            QLineEdit:focus, QTextEdit:focus, QComboBox:focus {
                border: 1px solid #3b82f6;
            }
            QLabel {
                color: #e4e4e7;
                font-size: 13px;
            }
            QListWidget {
                background-color: #1e293b;
                color: #f3f4f6;
                border: 1px solid #475569;
                border-radius: 6px;
                padding: 4px;
            }
            QListWidget::item {
                padding: 8px;
                border-radius: 4px;
                margin: 2px;
            }
            QListWidget::item:hover {
                background-color: #334155;
            }
            QListWidget::item:selected {
                background-color: #3b82f6;
            }
            QTabWidget::pane {
                border: 1px solid #475569;
                border-radius: 6px;
                background-color: #1e293b;
            }
            QTabBar::tab {
                background-color: #334155;
                color: #9ca3af;
                padding: 8px 16px;
                border-top-left-radius: 6px;
                border-top-right-radius: 6px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #3b82f6;
                color: white;
            }
            QSlider::groove:horizontal {
                height: 6px;
                background: #334155;
                border-radius: 3px;
            }
            QSlider::handle:horizontal {
                background: #3b82f6;
                width: 16px;
                margin: -5px 0;
                border-radius: 8px;
            }
            QSlider::handle:horizontal:hover {
                background: #60a5fa;
            }
        """)
    
    def on_provider_changed(self):
        self.current_provider = self.provider_combo.currentData()
        provider_info = PROVIDERS[self.current_provider]
        
        # Update API settings visibility
        if provider_info["requires_api_key"]:
            self.host_input.hide()
            self.host_input.parent().layout().itemAt(0).widget().hide()
            self.api_key_input.show()
            self.api_key_input.parent().layout().itemAt(2).widget().show()
            key_name = f"{self.current_provider}_api_key"
            self.api_key_input.setText(self.settings.get(key_name, ""))
        else:
            self.host_input.show()
            self.host_input.parent().layout().itemAt(0).widget().show()
            self.api_key_input.hide()
            self.api_key_input.parent().layout().itemAt(2).widget().hide()
            host_name = f"{self.current_provider}_host"
            self.host_input.setText(self.settings.get(host_name, ""))
        
        self.fetch_models()
    
    def fetch_models(self):
        self.model_combo.clear()
        self.model_status.setText("Loading models...")
        
        QTimer.singleShot(100, self._fetch_models_async)
    
    def _fetch_models_async(self):
        try:
            models = []
            
            if self.current_provider == "ollama":
                response = requests.get(f"{self.settings['ollama_host']}/api/tags", timeout=5)
                if response.status_code == 200:
                    models = [m['name'] for m in response.json().get('models', [])]
            
            elif self.current_provider == "lmstudio":
                response = requests.get(f"{self.settings['lmstudio_host']}/v1/models", timeout=5)
                if response.status_code == 200:
                    models = [m['id'] for m in response.json().get('data', [])]
            
            elif self.current_provider == "groq":
                api_key = self.settings.get('groq_api_key', '')
                if api_key:
                    response = requests.get(
                        "https://api.groq.com/openai/v1/models",
                        headers={"Authorization": f"Bearer {api_key}"},
                        timeout=10
                    )
                    if response.status_code == 200:
                        models = sorted([m['id'] for m in response.json().get('data', [])])
            
            elif self.current_provider == "openai":
                api_key = self.settings.get('openai_api_key', '')
                if api_key:
                    response = requests.get(
                        "https://api.openai.com/v1/models",
                        headers={"Authorization": f"Bearer {api_key}"},
                        timeout=10
                    )
                    if response.status_code == 200:
                        all_models = [m['id'] for m in response.json().get('data', [])]
                        models = sorted([m for m in all_models if 'gpt' in m.lower()], reverse=True)
            
            elif self.current_provider == "anthropic":
                models = [
                    "claude-sonnet-4-5-20250929",
                    "claude-3-5-sonnet-20241022",
                    "claude-3-5-haiku-20241022",
                    "claude-3-opus-20240229",
                    "claude-3-haiku-20240307"
                ]
            
            if models:
                self.model_combo.addItems(models)
                self.current_model = models[0]
                self.model_status.setText(f"‚úì {len(models)} models")
                self.model_status.setStyleSheet("color: #10b981;")
            else:
                self.model_status.setText("‚ö†Ô∏è No models found")
                self.model_status.setStyleSheet("color: #f59e0b;")
        
        except Exception as e:
            self.model_status.setText(f"Error: {str(e)[:30]}")
            self.model_status.setStyleSheet("color: #ef4444;")
    
    def update_host(self, text):
        host_name = f"{self.current_provider}_host"
        self.settings[host_name] = text
    
    def update_api_key(self, text):
        key_name = f"{self.current_provider}_api_key"
        self.settings[key_name] = text
    
    def update_slider(self, label, value, setting):
        if setting == "temperature":
            actual_value = value / 100.0
            self.settings[setting] = actual_value
            label.setText(f"Temperature: {actual_value:.2f}")
        else:
            self.settings[setting] = value
            label.setText(f"Max Tokens: {value}")
    
    def upload_file(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Open File", "", "Text Files (*.txt *.md *.json);;All Files (*)"
        )
        
        if file_path:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()[:5000]
                    self.uploaded_files.append({
                        "name": Path(file_path).name,
                        "content": content
                    })
                    self.file_status.setText(f"‚úì {Path(file_path).name}")
                    self.file_status.setStyleSheet("color: #10b981;")
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Failed to read file: {str(e)}")
    
    def new_chat(self):
        if self.messages and self.current_conversation_id:
            reply = QMessageBox.question(
                self, "New Chat", "Start a new chat? Current chat will be saved.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return
        
        self.messages = []
        self.current_conversation_id = None
        self.uploaded_files = []
        self.chat_display.clear()
        self.file_status.clear()
        self.display_welcome_message()
    
    def display_welcome_message(self):
        welcome_html = """
        <div style='text-align: center; padding: 50px;'>
            <h1 style='color: #60a5fa; font-size: 32px; margin-bottom: 20px;'>
                How can I help you today?
            </h1>
            <p style='color: #9ca3af; font-size: 16px;'>
                Choose a provider and model to get started
            </p>
        </div>
        """
        self.chat_display.setHtml(welcome_html)
    
    def send_message(self):
        message = self.message_input.toPlainText().strip()
        
        if not message:
            return
        
        self.current_model = self.model_combo.currentText()
        
        if not self.current_model:
            QMessageBox.warning(self, "No Model", "Please select a model first!")
            return
        
        # Clear input
        self.message_input.clear()
        
        # Create conversation if needed
        if not self.current_conversation_id:
            self.current_conversation_id = self.save_conversation(
                message[:50], self.current_provider, self.current_model
            )
        
        # Add context from uploaded files
        context = ""
        if self.uploaded_files:
            context = "\n\n[Context from files]:\n"
            for file in self.uploaded_files:
                context += f"\n--- {file['name']} ---\n{file['content']}\n"
        
        full_message = context + message if context else message
        
        # Add user message
        self.messages.append({"role": "user", "content": message})
        self.save_message(self.current_conversation_id, "user", message)
        self.display_message("user", message)
        
        # Disable send button
        self.send_btn.setEnabled(False)
        self.send_btn.setText("Thinking...")
        
        # Prepare messages for API
        api_messages = self.messages.copy()
        if context:
            api_messages[-1] = {"role": "user", "content": full_message}
        
        # Start API worker
        self.worker = APIWorker(
            self.current_provider,
            self.current_model,
            api_messages,
            self.settings
        )
        self.worker.finished.connect(self.on_response_received)
        self.worker.error.connect(self.on_response_error)
        self.worker.start()
    
    def on_response_received(self, response, input_tokens, output_tokens):
        # Add assistant message
        self.messages.append({"role": "assistant", "content": response})
        self.save_message(self.current_conversation_id, "assistant", response)
        self.display_message("assistant", response)
        
        # Save usage stats
        cost = (input_tokens / 1000) * 0.001 + (output_tokens / 1000) * 0.002
        self.save_usage_stats(
            self.current_conversation_id,
            self.current_provider,
            self.current_model,
            input_tokens,
            output_tokens,
            cost
        )
        
        # Re-enable send button
        self.send_btn.setEnabled(True)
        self.send_btn.setText("Send")
        
        # Update history
        self.load_history()
    
    def on_response_error(self, error):
        QMessageBox.critical(self, "Error", f"Failed to get response: {error}")
        self.send_btn.setEnabled(True)
        self.send_btn.setText("Send")
    
    def display_message(self, role, content):
        if role == "user":
            html = f"""
            <div style='background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #1e3a8a, stop:1 #1e40af);
                        border: 1px solid #3b82f6;
                        border-radius: 12px;
                        padding: 15px;
                        margin: 10px 50px 10px 0px;'>
                <div style='color: #93c5fd; font-weight: 600; margin-bottom: 8px;'>
                    üë§ You
                </div>
                <div style='color: #f3f4f6; line-height: 1.6;'>
                    {content.replace('\n', '<br>')}
                </div>
            </div>
            """
        else:
            provider_icons = {
                "ollama": "ü¶ô",
                "lmstudio": "üéØ",
                "groq": "‚ö°",
                "openai": "ü§ñ",
                "anthropic": "üîÆ"
            }
            icon = provider_icons.get(self.current_provider, "ü§ñ")
            
            html = f"""
            <div style='background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #1f2937, stop:1 #374151);
                        border: 1px solid #4b5563;
                        border-radius: 12px;
                        padding: 15px;
                        margin: 10px 0px 10px 50px;'>
                <div style='color: #93c5fd; font-weight: 600; margin-bottom: 8px;'>
                    {icon} Assistant
                </div>
                <div style='color: #f3f4f6; line-height: 1.6;'>
                    {content.replace('\n', '<br>')}
                </div>
            </div>
            """
        
        self.chat_display.moveCursor(QTextCursor.MoveOperation.End)
        self.chat_display.insertHtml(html)
        self.chat_display.moveCursor(QTextCursor.MoveOperation.End)
    
    def save_conversation(self, title, provider, model):
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        now = datetime.now()
        c.execute('''INSERT INTO conversations (title, provider, model, created_at, updated_at)
                     VALUES (?, ?, ?, ?, ?)''', (title, provider, model, now, now))
        conv_id = c.lastrowid
        conn.commit()
        conn.close()
        return conv_id
    
    def save_message(self, conversation_id, role, content):
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''INSERT INTO messages (conversation_id, role, content, timestamp)
                     VALUES (?, ?, ?, ?)''', (conversation_id, role, content, datetime.now()))
        conn.commit()
        conn.close()
    
    def save_usage_stats(self, conversation_id, provider, model, input_tokens, output_tokens, cost):
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''INSERT INTO usage_stats (conversation_id, provider, model, input_tokens, 
                     output_tokens, estimated_cost, timestamp)
                     VALUES (?, ?, ?, ?, ?, ?, ?)''',
                  (conversation_id, provider, model, input_tokens, output_tokens, cost, datetime.now()))
        conn.commit()
        conn.close()
    
    def load_history(self):
        self.history_list.clear()
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''SELECT id, title, provider, created_at FROM conversations 
                     ORDER BY updated_at DESC LIMIT 20''')
        conversations = c.fetchall()
        conn.close()
        
        for conv in conversations:
            conv_id, title, provider, created = conv
            item_text = f"üí¨ {title[:30]}..."
            from PyQt6.QtWidgets import QListWidgetItem
            item = QListWidgetItem(item_text)
            item.setData(Qt.ItemDataRole.UserRole, conv_id)
            self.history_list.addItem(item)
    
    def load_conversation(self, item):
        conv_id = item.data(Qt.ItemDataRole.UserRole)
        
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''SELECT role, content FROM messages 
                     WHERE conversation_id = ? ORDER BY timestamp''', (conv_id,))
        messages = [{"role": row[0], "content": row[1]} for row in c.fetchall()]
        conn.close()
        
        self.messages = messages
        self.current_conversation_id = conv_id
        self.chat_display.clear()
        
        for msg in messages:
            self.display_message(msg["role"], msg["content"])

def main():
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    
    window = ChatWindow()
    window.show()
    window.display_welcome_message()
    
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
