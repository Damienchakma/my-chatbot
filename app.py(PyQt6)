"""
Standalone AI Chat Desktop Application - Claude-like UI
Install requirements: pip install PyQt6 requests
Run: python desktop_chat_app.py
"""

import sys
import json
import requests
import sqlite3
from datetime import datetime
from pathlib import Path
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                             QHBoxLayout, QTextEdit, QPushButton, QLabel, 
                             QComboBox, QLineEdit, QListWidget, QSplitter,
                             QTabWidget, QSlider, QFileDialog, QMessageBox,
                             QScrollArea, QFrame, QTextBrowser, QListWidgetItem)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QFont

# Database setup
DB_PATH = "chat_history.db"

def init_database():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute('''CREATE TABLE IF NOT EXISTS conversations
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  title TEXT,
                  provider TEXT,
                  model TEXT,
                  created_at TIMESTAMP,
                  updated_at TIMESTAMP)''')
    
    c.execute('''CREATE TABLE IF NOT EXISTS messages
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  conversation_id INTEGER,
                  role TEXT,
                  content TEXT,
                  timestamp TIMESTAMP,
                  FOREIGN KEY (conversation_id) REFERENCES conversations(id))''')
    
    c.execute('''CREATE TABLE IF NOT EXISTS usage_stats
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  conversation_id INTEGER,
                  provider TEXT,
                  model TEXT,
                  input_tokens INTEGER,
                  output_tokens INTEGER,
                  estimated_cost REAL,
                  timestamp TIMESTAMP,
                  FOREIGN KEY (conversation_id) REFERENCES conversations(id))''')
    
    conn.commit()
    conn.close()

# Provider configurations
PROVIDERS = {
    "ollama": {
        "name": "Ollama (Local)",
        "icon": "ðŸ¦™",
        "requires_api_key": False,
        "default_host": "http://localhost:11434"
    },
    "lmstudio": {
        "name": "LM Studio (Local)",
        "icon": "ðŸŽ¯",
        "requires_api_key": False,
        "default_host": "http://localhost:1234"
    },
    "groq": {
        "name": "Groq",
        "icon": "âš¡",
        "requires_api_key": True
    },
    "openai": {
        "name": "OpenAI",
        "icon": "ðŸ¤–",
        "requires_api_key": True
    },
    "anthropic": {
        "name": "Anthropic",
        "icon": "ðŸ”®",
        "requires_api_key": True
    }
}

# Reasoning models that support thinking
REASONING_MODELS = ["deepseek-r1", "o1-preview", "o1-mini", "o1", "qwq"]

# API worker thread with streaming support
class APIWorker(QThread):
    chunk_received = pyqtSignal(str)
    thinking_chunk = pyqtSignal(str)
    finished = pyqtSignal(str, int, int)
    error = pyqtSignal(str)
    
    def __init__(self, provider, model, messages, settings):
        super().__init__()
        self.provider = provider
        self.model = model
        self.messages = messages
        self.settings = settings
        self.full_response = ""
        self.thinking_content = ""
    
    def run(self):
        try:
            if self.provider == "ollama":
                self.call_ollama_streaming()
            elif self.provider == "lmstudio":
                self.call_lmstudio_streaming()
            elif self.provider == "groq":
                self.call_groq_streaming()
            elif self.provider == "openai":
                self.call_openai_streaming()
            elif self.provider == "anthropic":
                self.call_anthropic_streaming()
            else:
                raise Exception("Unknown provider")
        except Exception as e:
            self.error.emit(str(e))
    
    def is_reasoning_model(self):
        return any(rm in self.model.lower() for rm in REASONING_MODELS)
    
    def call_ollama_streaming(self):
        prompt = "\n".join([f"{m['role']}: {m['content']}" for m in self.messages])
        response = requests.post(
            f"{self.settings['ollama_host']}/api/generate",
            json={
                "model": self.model,
                "prompt": prompt,
                "stream": True,
                "options": {
                    "temperature": self.settings['temperature'],
                    "num_predict": self.settings['max_tokens']
                }
            },
            stream=True,
            timeout=120
        )
        
        for line in response.iter_lines():
            if line:
                data = json.loads(line)
                chunk = data.get('response', '')
                if chunk:
                    self.full_response += chunk
                    self.chunk_received.emit(chunk)
                if data.get('done', False):
                    break
        
        self.finished.emit(self.full_response, 0, 0)
    
    def call_lmstudio_streaming(self):
        response = requests.post(
            f"{self.settings['lmstudio_host']}/v1/chat/completions",
            json={
                "model": self.model,
                "messages": self.messages,
                "temperature": self.settings['temperature'],
                "max_tokens": self.settings['max_tokens'],
                "stream": True
            },
            stream=True,
            timeout=120
        )
        
        for line in response.iter_lines():
            if line:
                line = line.decode('utf-8')
                if line.startswith('data: '):
                    line = line[6:]
                    if line.strip() == '[DONE]':
                        break
                    try:
                        data = json.loads(line)
                        chunk = data['choices'][0]['delta'].get('content', '')
                        if chunk:
                            self.full_response += chunk
                            self.chunk_received.emit(chunk)
                    except:
                        pass
        
        self.finished.emit(self.full_response, 0, 0)
    
    def call_groq_streaming(self):
        response = requests.post(
            "https://api.groq.com/openai/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {self.settings['groq_api_key']}",
                "Content-Type": "application/json"
            },
            json={
                "model": self.model,
                "messages": self.messages,
                "temperature": self.settings['temperature'],
                "max_tokens": self.settings['max_tokens'],
                "stream": True
            },
            stream=True,
            timeout=120
        )
        
        for line in response.iter_lines():
            if line:
                line = line.decode('utf-8')
                if line.startswith('data: '):
                    line = line[6:]
                    if line.strip() == '[DONE]':
                        break
                    try:
                        data = json.loads(line)
                        chunk = data['choices'][0]['delta'].get('content', '')
                        if chunk:
                            self.full_response += chunk
                            self.chunk_received.emit(chunk)
                    except:
                        pass
        
        self.finished.emit(self.full_response, 0, 0)
    
    def call_openai_streaming(self):
        response = requests.post(
            "https://api.openai.com/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {self.settings['openai_api_key']}",
                "Content-Type": "application/json"
            },
            json={
                "model": self.model,
                "messages": self.messages,
                "temperature": self.settings['temperature'],
                "max_tokens": self.settings['max_tokens'],
                "stream": True
            },
            stream=True,
            timeout=120
        )
        
        for line in response.iter_lines():
            if line:
                line = line.decode('utf-8')
                if line.startswith('data: '):
                    line = line[6:]
                    if line.strip() == '[DONE]':
                        break
                    try:
                        data = json.loads(line)
                        choice = data['choices'][0]
                        
                        if self.is_reasoning_model() and 'delta' in choice:
                            delta = choice['delta']
                            if 'reasoning_content' in delta:
                                thinking = delta['reasoning_content']
                                if thinking:
                                    self.thinking_content += thinking
                                    self.thinking_chunk.emit(thinking)
                            if 'content' in delta:
                                chunk = delta['content']
                                if chunk:
                                    self.full_response += chunk
                                    self.chunk_received.emit(chunk)
                        else:
                            chunk = choice['delta'].get('content', '')
                            if chunk:
                                self.full_response += chunk
                                self.chunk_received.emit(chunk)
                    except:
                        pass
        
        self.finished.emit(self.full_response, 0, 0)
    
    def call_anthropic_streaming(self):
        response = requests.post(
            "https://api.anthropic.com/v1/messages",
            headers={
                "x-api-key": self.settings['anthropic_api_key'],
                "anthropic-version": "2023-06-01",
                "Content-Type": "application/json"
            },
            json={
                "model": self.model,
                "messages": self.messages,
                "max_tokens": self.settings['max_tokens'],
                "temperature": self.settings['temperature'],
                "stream": True
            },
            stream=True,
            timeout=120
        )
        
        for line in response.iter_lines():
            if line:
                line = line.decode('utf-8')
                if line.startswith('data: '):
                    line = line[6:]
                    try:
                        data = json.loads(line)
                        if data.get('type') == 'content_block_delta':
                            chunk = data.get('delta', {}).get('text', '')
                            if chunk:
                                self.full_response += chunk
                                self.chunk_received.emit(chunk)
                    except:
                        pass
        
        self.finished.emit(self.full_response, 0, 0)

# Custom message widget
class MessageWidget(QFrame):
    def __init__(self, role, content="", provider_icon="ðŸ¤–", parent=None):
        super().__init__(parent)
        self.role = role
        self.content = content
        self.provider_icon = provider_icon
        self.thinking_content = ""
        self.setup_ui()
    
    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 15)
        
        container = QFrame()
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(20, 15, 20, 15)
        
        if self.role == "user":
            container.setStyleSheet("""
                QFrame {
                    background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                        stop:0 #1e3a8a, stop:1 #1e40af);
                    border: 1px solid #3b82f6;
                    border-radius: 16px;
                }
            """)
            layout.setContentsMargins(50, 0, 0, 0)
        else:
            container.setStyleSheet("""
                QFrame {
                    background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                        stop:0 #1f2937, stop:1 #374151);
                    border: 1px solid #4b5563;
                    border-radius: 16px;
                }
            """)
            layout.setContentsMargins(0, 0, 50, 0)
        
        header = QLabel()
        if self.role == "user":
            header.setText("ðŸ‘¤ You")
        else:
            header.setText(f"{self.provider_icon} Assistant")
        
        header.setStyleSheet("color: #93c5fd; font-weight: 600; font-size: 13px; margin-bottom: 8px;")
        container_layout.addWidget(header)
        
        # Thinking bubble
        self.thinking_widget = QFrame()
        thinking_layout = QVBoxLayout(self.thinking_widget)
        thinking_layout.setContentsMargins(15, 12, 15, 12)
        self.thinking_widget.setStyleSheet("""
            QFrame {
                background-color: rgba(59, 130, 246, 0.1);
                border: 1px solid rgba(59, 130, 246, 0.3);
                border-radius: 12px;
                margin-bottom: 12px;
            }
        """)
        
        thinking_header = QLabel("ðŸ’­ Thinking...")
        thinking_header.setStyleSheet("color: #60a5fa; font-weight: 600; font-size: 12px; margin-bottom: 6px;")
        thinking_layout.addWidget(thinking_header)
        
        self.thinking_text = QTextBrowser()
        self.thinking_text.setOpenExternalLinks(False)
        self.thinking_text.setStyleSheet("""
            QTextBrowser {
                background-color: transparent;
                border: none;
                color: #93c5fd;
                font-size: 13px;
            }
        """)
        self.thinking_text.setMaximumHeight(200)
        thinking_layout.addWidget(self.thinking_text)
        
        self.thinking_widget.hide()
        container_layout.addWidget(self.thinking_widget)
        
        # Content
        self.content_text = QTextBrowser()
        self.content_text.setOpenExternalLinks(True)
        self.content_text.setStyleSheet("""
            QTextBrowser {
                background-color: transparent;
                border: none;
                color: #f3f4f6;
                font-size: 14px;
            }
        """)
        
        if self.content:
            self.set_content(self.content)
        
        container_layout.addWidget(self.content_text)
        layout.addWidget(container)
    
    def set_content(self, content):
        self.content = content
        html_content = self.format_content(content)
        self.content_text.setHtml(html_content)
        self.adjust_height()
    
    def append_content(self, chunk):
        self.content += chunk
        html_content = self.format_content(self.content)
        self.content_text.setHtml(html_content)
        self.adjust_height()
    
    def append_thinking(self, chunk):
        self.thinking_content += chunk
        self.thinking_widget.show()
        html_thinking = self.format_content(self.thinking_content)
        self.thinking_text.setHtml(html_thinking)
    
    def format_content(self, text):
        import re
        html = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
        html = re.sub(r'```(\w+)?\n(.*?)```', 
                     r'<pre style="background-color: #1e1e1e; padding: 12px; border-radius: 6px; margin: 10px 0;"><code>\2</code></pre>', 
                     html, flags=re.DOTALL)
        html = re.sub(r'`([^`]+)`', 
                     r'<code style="background-color: #374151; padding: 2px 6px; border-radius: 4px; font-family: monospace;">\1</code>', 
                     html)
        html = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', html)
        html = html.replace('\n', '<br>')
        return f'<div style="font-family: Inter, sans-serif; line-height: 1.7;">{html}</div>'
    
    def adjust_height(self):
        doc_height = self.content_text.document().size().height()
        self.content_text.setMinimumHeight(int(doc_height) + 20)

# Main window
class ChatWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("AI Chat Assistant")
        self.setGeometry(100, 100, 1600, 1000)
        
        init_database()
        
        self.messages = []
        self.current_conversation_id = None
        self.current_provider = "ollama"
        self.current_model = ""
        self.uploaded_files = []
        self.current_message_widget = None
        
        self.settings = {
            "ollama_host": "http://localhost:11434",
            "lmstudio_host": "http://localhost:1234",
            "groq_api_key": "",
            "openai_api_key": "",
            "anthropic_api_key": "",
            "temperature": 0.7,
            "max_tokens": 2048
        }
        
        self.setup_ui()
        self.apply_theme()
        self.fetch_models()
    
    def setup_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        main_layout = QHBoxLayout(central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        splitter = QSplitter(Qt.Orientation.Horizontal)
        sidebar = self.create_sidebar()
        splitter.addWidget(sidebar)
        
        main_content = self.create_main_content()
        splitter.addWidget(main_content)
        
        splitter.setSizes([320, 1280])
        splitter.setStretchFactor(1, 1)
        
        main_layout.addWidget(splitter)
    
    def create_sidebar(self):
        sidebar = QFrame()
        sidebar.setMinimumWidth(300)
        sidebar.setMaximumWidth(400)
        
        layout = QVBoxLayout(sidebar)
        layout.setContentsMargins(15, 20, 15, 20)
        layout.setSpacing(15)
        
        title = QLabel("âš™ï¸ Settings")
        title.setFont(QFont("Inter", 14, QFont.Weight.Bold))
        layout.addWidget(title)
        
        self.new_chat_btn = QPushButton("ðŸ—¨ï¸ New Chat")
        self.new_chat_btn.clicked.connect(self.new_chat)
        layout.addWidget(self.new_chat_btn)
        
        layout.addSpacing(5)
        provider_label = QLabel("AI Provider")
        provider_label.setFont(QFont("Inter", 11, QFont.Weight.Bold))
        layout.addWidget(provider_label)
        
        for provider_id, info in PROVIDERS.items():
            btn = QPushButton(f"{info['icon']} {info['name']}")
            btn.setCheckable(True)
            btn.clicked.connect(lambda checked, p=provider_id: self.select_provider(p))
            if provider_id == self.current_provider:
                btn.setChecked(True)
            layout.addWidget(btn)
            setattr(self, f"provider_btn_{provider_id}", btn)
        
        layout.addSpacing(5)
        model_header = QHBoxLayout()
        model_label = QLabel("Model")
        model_label.setFont(QFont("Inter", 11, QFont.Weight.Bold))
        model_header.addWidget(model_label)
        model_header.addStretch()
        
        self.refresh_btn = QPushButton("ðŸ”„")
        self.refresh_btn.setMaximumWidth(35)
        self.refresh_btn.clicked.connect(self.fetch_models)
        model_header.addWidget(self.refresh_btn)
        layout.addLayout(model_header)
        
        self.model_combo = QComboBox()
        self.model_combo.currentTextChanged.connect(self.on_model_changed)
        layout.addWidget(self.model_combo)
        
        self.model_status = QLabel()
        layout.addWidget(self.model_status)
        
        layout.addSpacing(5)
        self.settings_tab = QTabWidget()
        
        api_widget = QWidget()
        api_layout = QVBoxLayout(api_widget)
        api_layout.setContentsMargins(10, 10, 10, 10)
        
        self.host_label = QLabel("Host:")
        api_layout.addWidget(self.host_label)
        
        self.host_input = QLineEdit()
        self.host_input.textChanged.connect(self.update_host)
        api_layout.addWidget(self.host_input)
        
        self.api_key_label = QLabel("API Key:")
        api_layout.addWidget(self.api_key_label)
        
        self.api_key_input = QLineEdit()
        self.api_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.api_key_input.textChanged.connect(self.update_api_key)
        api_layout.addWidget(self.api_key_input)
        
        api_layout.addStretch()
        
        params_widget = QWidget()
        params_layout = QVBoxLayout(params_widget)
        params_layout.setContentsMargins(10, 10, 10, 10)
        
        self.temp_label = QLabel(f"Temperature: {self.settings['temperature']:.2f}")
        params_layout.addWidget(self.temp_label)
        
        self.temp_slider = QSlider(Qt.Orientation.Horizontal)
        self.temp_slider.setMinimum(0)
        self.temp_slider.setMaximum(200)
        self.temp_slider.setValue(int(self.settings['temperature'] * 100))
        self.temp_slider.valueChanged.connect(self.update_temperature)
        params_layout.addWidget(self.temp_slider)
        
        self.tokens_label = QLabel(f"Max Tokens: {self.settings['max_tokens']}")
        params_layout.addWidget(self.tokens_label)
        
        self.tokens_slider = QSlider(Qt.Orientation.Horizontal)
        self.tokens_slider.setMinimum(256)
        self.tokens_slider.setMaximum(4096)
        self.tokens_slider.setSingleStep(256)
        self.tokens_slider.setValue(self.settings['max_tokens'])
        self.tokens_slider.valueChanged.connect(self.update_max_tokens)
        params_layout.addWidget(self.tokens_slider)
        
        params_layout.addStretch()
        
        self.settings_tab.addTab(api_widget, "API")
        self.settings_tab.addTab(params_widget, "Parameters")
        layout.addWidget(self.settings_tab)
        
        layout.addSpacing(5)
        file_label = QLabel("ðŸ“ Upload Files")
        file_label.setFont(QFont("Inter", 11, QFont.Weight.Bold))
        layout.addWidget(file_label)
        
        self.upload_btn = QPushButton("Choose File")
        self.upload_btn.clicked.connect(self.upload_file)
        layout.addWidget(self.upload_btn)
        
        self.file_status = QLabel()
        layout.addWidget(self.file_status)
        
        layout.addSpacing(5)
        history_label = QLabel("ðŸ’¬ Chat History")
        history_label.setFont(QFont("Inter", 11, QFont.Weight.Bold))
        layout.addWidget(history_label)
        
        self.history_list = QListWidget()
        self.history_list.itemClicked.connect(self.load_conversation)
        layout.addWidget(self.history_list)
        
        self.load_history()
        layout.addStretch()
        self.update_api_visibility()
        
        return sidebar
    
    def create_main_content(self):
        main_widget = QWidget()
        layout = QVBoxLayout(main_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll.setStyleSheet("QScrollArea { border: none; }")
        
        self.chat_container = QWidget()
        self.chat_layout = QVBoxLayout(self.chat_container)
        self.chat_layout.setContentsMargins(40, 30, 40, 30)
        self.chat_layout.setSpacing(0)
        self.chat_layout.addStretch()
        
        scroll.setWidget(self.chat_container)
        self.scroll_area = scroll
        layout.addWidget(scroll)
        
        input_container = QFrame()
        input_container.setStyleSheet("""
            QFrame {
                background-color: #1a1a2e;
                border-top: 1px solid #374151;
            }
        """)
        
        input_layout = QVBoxLayout(input_container)
        input_layout.setContentsMargins(40, 20, 40, 20)
        
        input_wrapper = QHBoxLayout()
        
        self.message_input = QTextEdit()
        self.message_input.setPlaceholderText("Type your message here...")
        self.message_input.setMaximumHeight(120)
        self.message_input.setMinimumHeight(60)
        self.message_input.setStyleSheet("""
            QTextEdit {
                background-color: #1e293b;
                color: #f3f4f6;
                border: 2px solid #475569;
                border-radius: 12px;
                padding: 12px 16px;
                font-size: 14px;
                font-family: Inter, sans-serif;
            }
            QTextEdit:focus {
                border: 2px solid #3b82f6;
            }
        """)
        input_wrapper.addWidget(self.message_input)
        
        self.send_btn = QPushButton("Send")
        self.send_btn.setMinimumHeight(60)
        self.send_btn.setMinimumWidth(100)
        self.send_btn.clicked.connect(self.send_message)
        input_wrapper.addWidget(self.send_btn)
        
        input_layout.addLayout(input_wrapper)
        layout.addWidget(input_container)
        
        self.display_welcome_message()
        
        return main_widget
    
    def apply_theme(self):
        self.setStyleSheet("""
            QMainWindow {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                    stop:0 #0f0f1e, stop:1 #1a1a2e);
            }
            QFrame {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #16213e, stop:1 #0f3460);
                border-right: 1px solid #1e3a5f;
            }
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #3b82f6, stop:1 #2563eb);
                color: white;
                border: none;
                border-radius: 8px;
                padding: 10px 16px;
                font-weight: 500;
                font-size: 13px;
                font-family: Inter, sans-serif;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #2563eb, stop:1 #1d4ed8);
            }
            QPushButton:pressed {
                background: #1e40af;
            }
            QPushButton:checked {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #1e40af, stop:1 #1e3a8a);
            }
            QPushButton:disabled {
                background: #475569;
                color: #9ca3af;
            }
            QLineEdit, QComboBox {
                background-color: #1e293b;
                color: #f3f4f6;
                border: 1px solid #475569;
                border-radius: 6px;
                padding: 8px 12px;
                font-size: 13px;
                font-family: Inter, sans-serif;
            }
            QLabel {
                color: #e4e4e7;
                font-size: 13px;
                font-family: Inter, sans-serif;
            }
            QListWidget {
                background-color: #1e293b;
                color: #f3f4f6;
                border: 1px solid #475569;
                border-radius: 8px;
                padding: 4px;
                font-family: Inter, sans-serif;
            }
            QListWidget::item {
                padding: 10px;
                border-radius: 6px;
                margin: 2px;
            }
            QListWidget::item:hover {
                background-color: #334155;
            }
            QListWidget::item:selected {
                background-color: #3b82f6;
            }
            QTabWidget::pane {
                border: 1px solid #475569;
                border-radius: 6px;
                background-color: #1e293b;
            }
            QTabBar::tab {
                background-color: #334155;
                color: #9ca3af;
                padding: 8px 16px;
                border-top-left-radius: 6px;
                border-top-right-radius: 6px;
                margin-right: 2px;
                font-family: Inter, sans-serif;
            }
            QTabBar::tab:selected {
                background-color: #3b82f6;
                color: white;
            }
            QSlider::groove:horizontal {
                height: 6px;
                background: #334155;
                border-radius: 3px;
            }
            QSlider::handle:horizontal {
                background: #3b82f6;
                width: 16px;
                margin: -5px 0;
                border-radius: 8px;
            }
            QScrollBar:vertical {
                background: #1e293b;
                width: 10px;
                border-radius: 5px;
            }
            QScrollBar::handle:vertical {
                background: #475569;
                border-radius: 5px;
            }
        """)
    
    def select_provider(self, provider_id):
        self.current_provider = provider_id
        for pid in PROVIDERS.keys():
            btn = getattr(self, f"provider_btn_{pid}")
            btn.setChecked(pid == provider_id)
        self.update_api_visibility()
        self.fetch_models()
    
    def update_api_visibility(self):
        provider_info = PROVIDERS[self.current_provider]
        if provider_info["requires_api_key"]:
            self.host_label.hide()
            self.host_input.hide()
            self.api_key_label.show()
            self.api_key_input.show()
            key_name = f"{self.current_provider}_api_key"
            self.api_key_input.setText(self.settings.get(key_name, ""))
        else:
            self.host_label.show()
            self.host_input.show()
            self.api_key_label.hide()
            self.api_key_input.hide()
            host_name = f"{self.current_provider}_host"
            self.host_input.setText(self.settings.get(host_name, ""))
    
    def fetch_models(self):
        self.model_combo.clear()
        self.model_status.setText("Loading...")
        self.model_status.setStyleSheet("color: #f59e0b;")
        QTimer.singleShot(100, self._fetch_models_async)
    
    def _fetch_models_async(self):
        try:
            models = []
            
            if self.current_provider == "ollama":
                response = requests.get(f"{self.settings['ollama_host']}/api/tags", timeout=5)
                if response.status_code == 200:
                    models = [m['name'] for m in response.json().get('models', [])]
            
            elif self.current_provider == "lmstudio":
                response = requests.get(f"{self.settings['lmstudio_host']}/v1/models", timeout=5)
                if response.status_code == 200:
                    models = [m['id'] for m in response.json().get('data', [])]
            
            elif self.current_provider == "groq":
                api_key = self.settings.get('groq_api_key', '')
                if api_key:
                    response = requests.get(
                        "https://api.groq.com/openai/v1/models",
                        headers={"Authorization": f"Bearer {api_key}"},
                        timeout=10
                    )
                    if response.status_code == 200:
                        models = sorted([m['id'] for m in response.json().get('data', [])])
            
            elif self.current_provider == "openai":
                api_key = self.settings.get('openai_api_key', '')
                if api_key:
                    response = requests.get(
                        "https://api.openai.com/v1/models",
                        headers={"Authorization": f"Bearer {api_key}"},
                        timeout=10
                    )
                    if response.status_code == 200:
                        all_models = [m['id'] for m in response.json().get('data', [])]
                        models = sorted([m for m in all_models if 'gpt' in m.lower()], reverse=True)
            
            elif self.current_provider == "anthropic":
                models = [
                    "claude-sonnet-4-5-20250929",
                    "claude-3-5-sonnet-20241022",
                    "claude-3-5-haiku-20241022",
                    "claude-3-opus-20240229",
                    "claude-3-haiku-20240307"
                ]
            
            if models:
                self.model_combo.addItems(models)
                self.current_model = models[0]
                self.model_status.setText(f"âœ“ {len(models)} models")
                self.model_status.setStyleSheet("color: #10b981;")
            else:
                self.model_status.setText("âš ï¸ No models")
                self.model_status.setStyleSheet("color: #f59e0b;")
        
        except Exception as e:
            self.model_status.setText("âŒ Error")
            self.model_status.setStyleSheet("color: #ef4444;")
    
    def on_model_changed(self, model):
        self.current_model = model
    
    def update_host(self, text):
        self.settings[f"{self.current_provider}_host"] = text
    
    def update_api_key(self, text):
        self.settings[f"{self.current_provider}_api_key"] = text
    
    def update_temperature(self, value):
        temp = value / 100.0
        self.settings['temperature'] = temp
        self.temp_label.setText(f"Temperature: {temp:.2f}")
    
    def update_max_tokens(self, value):
        self.settings['max_tokens'] = value
        self.tokens_label.setText(f"Max Tokens: {value}")
    
    def upload_file(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Open File", "", "Text Files (*.txt *.md *.json);;All Files (*)"
        )
        if file_path:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()[:5000]
                    self.uploaded_files.append({"name": Path(file_path).name, "content": content})
                    self.file_status.setText(f"âœ“ {Path(file_path).name}")
                    self.file_status.setStyleSheet("color: #10b981;")
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Failed to read file: {str(e)}")
    
    def new_chat(self):
        if self.messages:
            reply = QMessageBox.question(
                self, "New Chat", "Start a new chat? Current chat will be saved.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return
        
        self.messages = []
        self.current_conversation_id = None
        self.uploaded_files = []
        self.file_status.clear()
        
        while self.chat_layout.count() > 1:
            item = self.chat_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        self.display_welcome_message()
    
    def display_welcome_message(self):
        welcome = QLabel()
        welcome.setAlignment(Qt.AlignmentFlag.AlignCenter)
        welcome.setText("""
            <div style='text-align: center; padding: 80px 40px;'>
                <h1 style='color: #60a5fa; font-size: 36px; margin-bottom: 20px; font-weight: 700;'>
                    How can I help you today?
                </h1>
                <p style='color: #9ca3af; font-size: 16px;'>
                    Choose a provider and model to get started
                </p>
            </div>
        """)
        self.chat_layout.insertWidget(self.chat_layout.count() - 1, welcome)
    
    def send_message(self):
        message = self.message_input.toPlainText().strip()
        if not message or not self.current_model:
            if not self.current_model:
                QMessageBox.warning(self, "No Model", "Please select a model first!")
            return
        
        if self.chat_layout.count() > 1:
            first_item = self.chat_layout.itemAt(0)
            if first_item and first_item.widget() and isinstance(first_item.widget(), QLabel):
                first_item.widget().deleteLater()
        
        self.message_input.clear()
        
        if not self.current_conversation_id:
            self.current_conversation_id = self.save_conversation(
                message[:50], self.current_provider, self.current_model
            )
        
        context = ""
        if self.uploaded_files:
            context = "\n\n[Context from files]:\n"
            for file in self.uploaded_files:
                context += f"\n--- {file['name']} ---\n{file['content']}\n"
        
        full_message = context + message if context else message
        
        self.messages.append({"role": "user", "content": message})
        self.save_message(self.current_conversation_id, "user", message)
        
        user_widget = MessageWidget("user", message)
        self.chat_layout.insertWidget(self.chat_layout.count() - 1, user_widget)
        
        provider_icon = PROVIDERS[self.current_provider]['icon']
        assistant_widget = MessageWidget("assistant", "", provider_icon)
        self.chat_layout.insertWidget(self.chat_layout.count() - 1, assistant_widget)
        self.current_message_widget = assistant_widget
        
        QTimer.singleShot(100, self.scroll_to_bottom)
        
        self.send_btn.setEnabled(False)
        self.send_btn.setText("Thinking...")
        
        api_messages = self.messages.copy()
        if context:
            api_messages[-1] = {"role": "user", "content": full_message}
        
        self.worker = APIWorker(self.current_provider, self.current_model, api_messages, self.settings)
        self.worker.chunk_received.connect(self.on_chunk_received)
        self.worker.thinking_chunk.connect(self.on_thinking_chunk)
        self.worker.finished.connect(self.on_response_finished)
        self.worker.error.connect(self.on_response_error)
        self.worker.start()
    
    def on_chunk_received(self, chunk):
        if self.current_message_widget:
            self.current_message_widget.append_content(chunk)
            QTimer.singleShot(50, self.scroll_to_bottom)
    
    def on_thinking_chunk(self, chunk):
        if self.current_message_widget:
            self.current_message_widget.append_thinking(chunk)
            QTimer.singleShot(50, self.scroll_to_bottom)
    
    def on_response_finished(self, full_response, input_tokens, output_tokens):
        self.messages.append({"role": "assistant", "content": full_response})
        self.save_message(self.current_conversation_id, "assistant", full_response)
        
        cost = (input_tokens / 1000) * 0.001 + (output_tokens / 1000) * 0.002
        self.save_usage_stats(self.current_conversation_id, self.current_provider,
                             self.current_model, input_tokens, output_tokens, cost)
        
        self.send_btn.setEnabled(True)
        self.send_btn.setText("Send")
        self.current_message_widget = None
        self.load_history()
    
    def on_response_error(self, error):
        QMessageBox.critical(self, "Error", f"Failed to get response:\n{error}")
        self.send_btn.setEnabled(True)
        self.send_btn.setText("Send")
        if self.current_message_widget:
            self.current_message_widget.deleteLater()
            self.current_message_widget = None
    
    def scroll_to_bottom(self):
        if hasattr(self, 'scroll_area'):
            scroll_bar = self.scroll_area.verticalScrollBar()
            scroll_bar.setValue(scroll_bar.maximum())
    
    def save_conversation(self, title, provider, model):
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        now = datetime.now()
        c.execute('''INSERT INTO conversations (title, provider, model, created_at, updated_at)
                     VALUES (?, ?, ?, ?, ?)''', (title, provider, model, now, now))
        conv_id = c.lastrowid
        conn.commit()
        conn.close()
        return conv_id
    
    def save_message(self, conversation_id, role, content):
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''INSERT INTO messages (conversation_id, role, content, timestamp)
                     VALUES (?, ?, ?, ?)''', (conversation_id, role, content, datetime.now()))
        conn.commit()
        conn.close()
    
    def save_usage_stats(self, conversation_id, provider, model, input_tokens, output_tokens, cost):
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''INSERT INTO usage_stats (conversation_id, provider, model, input_tokens, 
                     output_tokens, estimated_cost, timestamp)
                     VALUES (?, ?, ?, ?, ?, ?, ?)''',
                  (conversation_id, provider, model, input_tokens, output_tokens, cost, datetime.now()))
        conn.commit()
        conn.close()
    
    def load_history(self):
        self.history_list.clear()
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''SELECT id, title, provider, created_at FROM conversations 
                     ORDER BY updated_at DESC LIMIT 20''')
        conversations = c.fetchall()
        conn.close()
        
        for conv in conversations:
            conv_id, title, provider, created = conv
            item = QListWidgetItem(f"ðŸ’¬ {title[:30]}...")
            item.setData(Qt.ItemDataRole.UserRole, conv_id)
            self.history_list.addItem(item)
    
    def load_conversation(self, item):
        conv_id = item.data(Qt.ItemDataRole.UserRole)
        
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''SELECT role, content FROM messages 
                     WHERE conversation_id = ? ORDER BY timestamp''', (conv_id,))
        messages = [{"role": row[0], "content": row[1]} for row in c.fetchall()]
        conn.close()
        
        self.messages = messages
        self.current_conversation_id = conv_id
        
        while self.chat_layout.count() > 1:
            item = self.chat_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        provider_icon = PROVIDERS[self.current_provider]['icon']
        for msg in messages:
            if msg["role"] == "user":
                widget = MessageWidget("user", msg["content"])
            else:
                widget = MessageWidget("assistant", msg["content"], provider_icon)
            self.chat_layout.insertWidget(self.chat_layout.count() - 1, widget)
        
        QTimer.singleShot(100, self.scroll_to_bottom)

def main():
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    font = QFont("Inter", 10)
    app.setFont(font)
    
    window = ChatWindow()
    window.show()
    
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
